---
title: "Feature Engineering"
output: html_document
date: "2025-11-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("settings.R")
df <- read.csv(file.path(path_intermediate, "train_imputed.csv"))
```

# 1. Lectura de Datos y Conversión Inicial

Key (0-11) y time_signature (0, 1, 3, 4, 5) son numéricas en el fichero, pero no tienen propiedades matemáticas. Las convertimos a factor, le decimos a R que son etiquetas nominales. audio_mode (0/1) también se beneficia de ser un factor para que el modelo lo trate como dos grupos distintos.

```{r}
# Lista de variables categóricas
vars_categoricas <- c("key", "time_signature", "audio_mode")

df <- df %>%
  mutate(across(all_of(vars_categoricas), ~ as.factor(.x)))

# Comprobamos
str(df)
```


# 2. Variables Categóricas (OHE)

Aplicamos OHE para variables nominales con más de dos niveles, ya que permite a los modelos matemáticos (Regresión, KNN) usarlas sin asumir una relación ordinal falsa.

```{r}
# Creamos las variables dummy. 
# audio_mode no es necesaria aquí, R la manejará como 0/1.
# Conservamos las originales con remove_selected_columns = FALSE
df <- dummy_cols(df, 
                 select_columns = c("key", "time_signature"),
                 remove_first_dummy = TRUE, # Para evitar multicolinealidad
                 remove_selected_columns = FALSE) # Conserva las originales
```

# 3. instrumentalness (Exceso de Ceros)
Dado que la mayoría de canciones no son instrumentales (mediana 0.00), el hecho de ser o no instrumental puede ser más predictivo que su valor exacto.

```{r}
# Usamos un umbral (ej. 0.1) para decidir si es instrumental
df <- df %>%
  mutate(es_instrumental = ifelse(instrumentalness > 0.1, 1, 0))

```

# 4. Variables con Asimetría Positiva

El logaritmo "comprime" la cola derecha de la distribución, acercando los outliers al resto de los datos. Usamos log1p (que calcula log(x + 1)) para manejar correctamente los valores 0.

```{r}
# Lista de variables con asimetría positiva
vars_pos_skew <- c("song_duration_ms", "acousticness", "liveness", 
                     "speechiness", "instrumentalness")

df <- df %>%
  mutate(across(all_of(vars_pos_skew), 
                ~ log1p(.x), 
                .names = "{.col}_log")) # <-- '.names' CREA NUEVAS COLUMNAS

```

# 5. Variable audio_valence (Plana/Uniforme)
Al ser la distribución tan plana, realizar una Discretización puede ayudar al modelo a encontrar puntos de corte claros.

```{r}
df <- df %>%
  mutate(valence_binned = cut(audio_valence,
                               breaks = c(0, 0.33, 0.66, 1.0),
                               labels = c("valence_baja", "valence_media", "valence_alta"),
                               include.lowest = TRUE))

# Ahora, aplicamos OHE a esta nueva variable categórica
df <- dummy_cols(df, 
                 select_columns = c("valence_binned"),
                 remove_first_dummy = TRUE, 
                 remove_selected_columns = FALSE) # Conserva la original
```


# 6. Escalado de Todas las Variables Numéricas

Asegura que todas las variables tengan la misma escala (media 0, std 1). Sin esto, por ejemplo tempo (rango >100) dominaría el cálculo de distancia sobre danceability (rango 1).

Este paso lo deberíamos repetir con las variables que probemos en cada modelo.

```{r}
# Identificamos TODAS las variables numéricas que irán al modelo
# Este caso incluye todas
vars_to_scale <- c("danceability", "energy", "tempo", "loudness", 
                     "song_duration_ms_log", "acousticness_log", "liveness_log", 
                     "speechiness_log", "instrumentalness_log")

# Estandariza (escala) y crea nuevas columnas
df <- df %>%
  mutate(across(all_of(vars_to_scale), 
                ~ as.vector(scale(.x)), 
                .names = "{.col}_scaled")) # CREA NUEVAS COLUMNAS
```


# 7 Columnas relevantes para los modelos
## 7.1 Columnas para el Modelo knn con la VIM function kNN()

```{r}
df_knn_vim <- df %>%
  dplyr::select(
    # 1. La variable objetivo
    song_popularity, 
    
    # 2. Las variables numéricas ya escaladas
    ends_with("_scaled"),
    
    # 3. La nueva feature binaria
    es_instrumental,
    
    # 4. El 'audio_mode' original (que ya es 0/1 o factor)
    audio_mode,
    
    # 5. Todas las dummies (OHE) creadas
    starts_with("key_"),
    starts_with("time_signature_"),
    starts_with("valence_binned_")
  )

# Ahora, 'df_knn_vim' está perfectamente limpio y listo para entrenar KNN
# sin redundancia de datos.
str(df_knn_vim)
```

## 7.2 Columnas para el Modelo knn usando FactoMineR::FAMD() y caret::train(method = "knn")
```{r}
df_knn_caret <- df %>%
  select(
    -ID,
    -ends_with("_scaled"),
    -ends_with("_log"),
    # 3. La nueva feature binaria
    -instrumentalness,
    # 5. Todas las dummies (OHE) creadas
    -starts_with("key_"),
    -starts_with("time_signature_"),
    -starts_with("valence_binned_")
  ) %>%
  select(song_popularity, everything())

str(df_knn_caret)
```

## Columnas para el modelo SVM

The algorithm SVM within the package "caret" already implement the centering and scaling of the variables. This algorithm is very heavy to train, for this reason we try to keep only the most important predictors, according to the exploratory analysis. 

First dataset: keep all the variables except liveness, speechiness, tempo.
Second dataset: keep danceability, energy, acousticness, instrumentalness.

```{r}
df_svm1 <- df %>%
  dplyr::select(
    song_popularity, 
    loudness,  
    danceability,
    song_duration_ms,
    energy,
    acousticness,
    es_instrumental,
    
    audio_mode,

    starts_with("key_"),
    starts_with("time_signature_"),
    starts_with("valence_binned_")
  )


str(df_svm1)
```
```{r}
#keep only the most important variables 
df_svm2 <- df %>%
  dplyr::select(
    song_popularity,
    danceability,
    energy,
    acousticness,
    es_instrumental,

  )
```



# 7. Guardar los resultados del feature engineering (df_knn_) como csv
```{r}
write.csv(df_knn_vim, file = file.path(path_intermediate, "train_knn_vim.csv"),
          row.names = FALSE)
write.csv(df_knn_caret, file = file.path(path_intermediate, "train_knn_caret.csv"),
          row.names = FALSE)

write.csv(df_svm1, file = file.path(path_intermediate, "train_svm1.csv"),
          row.names = FALSE)

write.csv(df_svm2, file = file.path(path_intermediate, "train_svm2.csv"),
          row.names = FALSE)

```




